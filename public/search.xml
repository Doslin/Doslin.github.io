<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[怎么看待.jsp后缀的URL请求越来越少了]]></title>
    <url>%2FJava%2F2019%2F05%2F22%2F%E6%80%8E%E4%B9%88%E7%9C%8B%E5%BE%85.jsp%E5%90%8E%E7%BC%80%E7%9A%84URL%E8%AF%B7%E6%B1%82%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%B0%91%E4%BA%86%2F</url>
    <content type="text"><![CDATA[MVC项目中一般不直接访问.JSP今天我同学问我，为什么我的项目的请求的后缀的是jsp ,在MVC的项目中，一般不会直接去访问JSP，都是通过.do来转发，这样做的好处是： 所有请求都通过action来转发，这样便于整体框架的处理。比如，可以加入登录到某个页面的权限控制，只需要在配置文件中配置，而不用再每个JSP中加入相关的逻辑。 与数据，文件等底层存储层连接，读取数据的代码可以在类中。这样做，一方面可以将很多方法复用，另一面使JSP页面的代码变得简单而容易维护。 其实.do也就是MVC当中的C,是控制器。在整个系统中起到中央枢纽的作用。先通过它的话就可以把逻辑代码隐藏在后台，使JSP文件作为单纯的VIEW分离出来，降低了系统的耦合性(比如说regist.do对应的就是regist.jsp这个页面,通过网页可能所有的跳转都是跳到regist.do去注册,但实际上直接输入regist.jsp应该也是可以打开一样的页面去注册，用不着去修改JSP，而是可以配置访问每个action所需要的权限，改动量小) 怎么看待.jsp后缀的URL请求越来越少了？​ 谈谈JSP文件。jsp是HTML页面中内嵌的Java代码。 第一种解释 一个原因是jsp也的确是用的少了。最早jsp是放在tomcat或者jetty这种servlet容器中来用的，jsp会被转换成servlet并且编译成.class文件，但是做routing的时候，默认还是用xxx.jsp来找到这个servlet. 所以以前三大门户时代，我们是经常看到jsp结尾的网站，那时候jsp的性能是非常好的，毕竟有编译嘛。现在我们还经常看到的javabean，其实我最早是在jsp+javabean这个模式中看到的。不过现在新项目已经没人这么干了，有直接用jsp做后台开发的,因为本质上是一个class类,可以方便的调用后台其他类.不过这样违反mvc的开发原则,也不符合前后端分离的开发模式,代码无法维护,最重要的是你需要不时的使用丑陋的&lt;%= &gt;符号标注java部分,最终导致代码无法阅读。 在大前端飞速发展的今天,甚至出现了完全前后端分离的模式,即全部页面都是用ajax请求,后台提供相应的api,所以jsp最终肯定要成为过去式.它只是一个模板。 第二个原因是就算用，也不是像早期php那样每个页面做一个jsp，然后里面jdbc直接到数据库了。而是仅仅把jsp作为一个模版语言，当作mvc模式中的view来使用。这样在url上，你是看不出它的view是jsp的。比如说/product/333这样的url, 它只要能找到对应的controller就好，你根本看不出来它的view是用什么技术做的。而且为了简单的SEO优化（早期搜索引擎比较愚蠢），很多都是优先HTML后缀的构建索引。 第二种解释 JSP本身就是一个后端的模板引擎，(jsp文件支持在标准的HTML页面插入Java代码，把Java代码运行的结果映射到HTML页面中，使用编译器编译hello.jsp，编译出的class文件里描述的是一个servlet，这个servlet的任务就是运行插入的Java代码，生成Java代码的结果，插入到HTML页面对应的位置，然后传给输出流。此时输出流里面的数据就和原生的HTML文件一模一样，也因此才能在客户端的浏览器上被识别和运行。这个编译的过程只会在第一次调用该文件的时候执行，之后就不会调用该文件进行编译，而是直接使用编译后的class字节码文件)，只是现在的MVC框架也很少的把页面及后缀暴露在URL上，而是经过一系列的重定向，————通过映射隐藏服务器的真实资源路径是最基本的防黑做法，意思是加入你看到的是http://www.http://abc.com/index.jsp，这个url，它的index.jsp并不是一定在根目录下，具体的路径是被隐藏起来的，由程序来指定。网页后缀和网页技术没有必然的联系 MVC的设计模式，JSP之所以被编译为Servlet，而不直接使用Servlet输出HTML，恰好就是将视图和控制层分离的体现，还有Servlet之所以要编译为Servlet是为了更高的性能，其他的模板引擎也有类似的做法。而不是让你认为他是一个servlet, 。当你写一个jsp页面并运行后,观察下tomcat编译后的文件,会生成相应的*.class,也就说jsp本质上是servlet. 反编译该class文件,你会发现该文件中获取到你的请求,并处理业务逻辑,然后把结果封装为html输出. ​ 所以访问的页面都是发送的请求,而不是静态的xx.jsp文件,拦截器拦截到该请求后调用相应的servlet处理业务逻辑,然后结果被封装为静态文件xx.html输出. 而输出的页面怎么写呢?很麻烦吧?所以jsp的作用就是使用一个模板,用特殊占位符(比如jstl)来站位并控制简单逻辑,后台servlet处理完业务逻辑会按照相应的jsp模板替换为xx.html输出. ​ 当然也有直接用jsp做后台开发的,因为本质上是一个class类,可以方便的调用后台其他类.不过这样违反mvc的开发原则,也不符合前后端分离的开发模式,代码无法维护,最重要的是你需要不时的使用丑陋的&lt;%= &gt;符号标注java部分,最终导致代码无法阅读. ​ 当使用框架之后,可以方便的控制请求后缀,java中一般使用 xx.do xx.action xx.html xx等,没有特殊的意思,只是为了使拦截器方便的区分静态文件(.css .js等)与请求. ​ jsp最为一种古老的技术,个人开发中感觉已经很少了.比如现在的jfinal开发框架直接使用html模板,使用自定义的标签,方便快速. ​ 在大前端飞速发展的今天,甚至出现了完全前后端分离的模式,即全部页面都是用ajax请求,后台提供相应的api,所以jsp最终肯定要成为过去式.它只是一个模板. 附加知识评论： 来自知乎123JSP文件支持在标准的HTML页面中插入Java代码，那么插入这些代码有什么用呢？刚学习JSP的人往往可以脱口而出，就是把Java代码运行的结果映射到HTML页面中，从而实现从服务器向客户端传值(当然不可能只是传值的功能)，但是，比如当我们输入xxx.jsp的时候，为什么浏览器端拿到的数据里，只有HTML页面和一些值，却没有拿到原本的Java代码呢(也就是说拿到的并不是原JSP文件)这个现象正好说明了："文件"和"资源"不是一个概念。"资源"只是一个标识，服务器拿到标识后，会经过一系列的转换，映射到某一种操作上去。有时候，这个操作是获取一个静态文件，原封不动的传入输出流，经过HTTP协议的封装后传到客户端；有时候，这个操作是让服务器进行计算，然后动态的生成数据到输出流中，在经过HTTP协议封装—而这里动态生成的数据，有的看起来也是一个静态文件，有的看起来则五花八门。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Chat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO下的Markdown语法(GFM)写博客]]></title>
    <url>%2FHexo%2F2019%2F05%2F22%2FHEXO%E4%B8%8B%E7%9A%84Markdown%E8%AF%AD%E6%B3%95(GFM)%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Markdown 是一种轻量级的「标记语言」，优点在于 专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 并且具有以下特点： 自动生成目录 代码块高亮 引用展示 表格插入 图片插入 强调显示 列表显示 自动URL链接 Hexo下使用的MarkDown为Github的GFM，风格很漂亮，简洁美观大方。但是GFM 的MarkDown语法和标准 的MarkDown稍有不同，使用过程中需要注意一些。 语法简明概述 分段 两个回车 换行 两个空格 + 回车 标题 # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题 强调 **文字** ， __文字__ ， _文字_ ， *文字* ， ~~文字~~ 引用 &gt; 注意后面紧跟个空格 表格 - 和 | 分割行和列 ， : 控制对其方式 代码块 四个空格 **开头或 链接 [文字](链接地址) 图片 ![图片说明](图片地址) ，地址可以是本地路径，也可以是网络地址 列表 * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格 标题12345678910# 欢迎使用Markdown编辑器写博客 //一级标题 对应 &lt;h1&gt; &lt;/h1&gt;## 标题输入 //二级标题 对应 &lt;h2&gt; &lt;/h2&gt;### 三级标题 //三级标题 对应 &lt;h3&gt; &lt;/h3&gt;#### 四级标题 //四级标题 对应 &lt;h4&gt; &lt;/h4&gt;##### 五级标题 //五级标题 对应 &lt;h5&gt; &lt;/h5&gt;###### 六级标题 //六级标题 对应 &lt;h6&gt; &lt;/h6&gt;####### 七级标题 //抱歉，木有了（但是他会影响生成的目录，目录行多出一行空行）二级标题 //二级标题 对应 &lt;h2&gt; &lt;/h2&gt;---- //这里添加四个'－' （减号） 这里不做展示了，影响目录的展示。 内容强调加粗、斜体123字体 **加粗** 显示字体 *斜体* 显示字体 ***加粗并斜体*** 显示 字体 加粗 显示字体 斜体 显示字体 加粗并斜体 显示 1234字体 __加粗__ 显示字体 _斜体_ 显示字体 ___加粗并斜体___ 显示组合 *__加粗并斜体__* 显示 字体 加粗 显示字体 _斜体_ 显示字体 加粗并斜体 显示组合 加粗并斜体 显示 删除线1这样来 ~~删除一段文本~~ 这样来 删除一段文本 高亮12使用&lt;code&gt;\`&lt;/code&gt;来强调字符 //想打出 ` (反引号)需要转义的，加&lt;code&gt;&lt;/code&gt;标签强调比如`突出背景色`来显示强调效果 使用来强调字符 比如突出背景色`来显示强调效果 引用显示引用过程中任然支持Markdown语法！ 标准使用12345678&gt; 每行开始都使用 '&gt;'；&gt; 引用**开始**；&gt; 引用**换行**；&gt; 引用**结束**。&gt; 还在引用中！两个回车结束引用！ 每行开始都使用 ‘&gt;’；引用开始；引用换行；引用结束。 还在引用中！ 两个回车结束引用！ 省略使用123456&gt; 仅第一行加应用；引用**开始**；引用**换行**；引用**结束**；两个回车结束引用,不在引用范围内了！ 仅第一行加应用；引用开始；引用换行；引用结束； 两个回车 结束引用,不在引用范围内了！ 嵌套使用123456789101112131415&gt; 动物&gt;&gt; 水生动物&gt;&gt; 陆生动物&gt;&gt;&gt; 猴子&gt;&gt;&gt; 人&gt;&gt;&gt;&gt; 程序猿&gt;&gt;&gt;&gt; 攻城狮&gt;&gt;产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记射鸡虱 //这里需要注意，没有空行间隔，忽略降级引用标记&gt;&gt; 两栖类动物&gt;&gt;&gt; 大鳄鱼唐老鸭两个回车结束引用,不在引用范围内了！ 动物 水生动物陆生动物 猴子人 程序猿攻城狮产品狗 这里需要注意，没有空行间隔，忽略降级引用标记射鸡虱 这里需要注意，没有空行间隔，忽略降级引用标记 两栖类动物 大鳄鱼唐老鸭 两个回车 结束引用,不在引用范围内了！ 表格 表格语法： 123456&gt; 列1 | 列2 | 列3 &gt; ----- | --- | ---- &gt; 第1行 | 12 | 13 &gt; 第2行 | 22 | 23 &gt; 第3行 | 32 | 33&gt; 列1 列2 列3 第1行 12 13 第2行 22 23 第3行 32 33 可以使用冒号来定义对齐方式： 12345&gt; | 左对齐 | 右对齐 | 居中 |&gt; | :-------- | -------:| :--: |&gt; | Computer | 5000 元 | 1台 |&gt; | Phone | 1999 元 | 1部 |&gt; 左对齐 右对齐 居中 Computer 5000 元 1台 Phone 1999 元 1部 代码块代码块语法遵循标准 markdown 代码，使用 开始，结束，例如： 1234#!/usr/bin/env python# -*- coding: utf-8 -*-print 'Hello World! 以上代码框及代码输入内容 1234&gt; #!/usr/bin/env python&gt; # -*- coding: utf-8 -*-&gt; print 'Hello World!'&gt; 特别提示 如何在代码块中打出 1&gt; ​ 复制到你的markdown中看看去吧！​1&gt; 实际上是使用 4个包含 3个 就可以了，想表示更多，最外层+1就好了。 12345&gt; &gt; ```&gt; ```&gt; &gt; 列表无序列表123456789* `*`列表展示* `*`列表展示 * `*`列表展示+ `+`列表展示+ `+`列表展示 + `+`列表展示- `-`列表展示- `-`列表展示 - `-`列表展示 *列表展示 1* 列表展示 *列表展示 +列表展示 1+ 列表展示 +列表展示 -列表展示 1- 列表展示 -列表展示 有序列表123456789101112这种方式不用手动设置序号，自动生成列表序列1. **我是一级序列** 1. **我是一级序列** 1. **我是一级序列** 1. *我是二级序列* 1. *我是二级序列* 1. *我是二级序列* 1. **我是一级序列** 1. **我是一级序列** 1. *我是二级序列* 1. *我是二级序列* 1. 还是二级序列，没有三级序列 这种方式不用手动设置序号，自动生成列表序列 我是一级序列 我是一级序列 我是一级序列 我是二级序列 多于一级序列一个空格 我是二级序列 多于一级序列一个空格 我是二级序列 多于一级序列一个空格 我是一级序列 我是一级序列 我是二级序列 多于一级序列一个空格 我是二级序列 多于一级序列一个空格 还是二级序列，没有三级序列 虽然多于二级序列一个空格，但是任然是二级序列]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedHashMap-LRU]]></title>
    <url>%2FJava%2F2019%2F05%2F21%2FLinkedHashMap-LRU%2F</url>
    <content type="text"><![CDATA[LinkedHashMap可认为是哈希表和链接列表综合实现，并允许使用null值和null键。LinkedHashMap实现与HashMap的不同之处在于，LinkedHashMap维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。 LinkedHashMap的实现不是同步的。如果多个线程同时访问LinkedHashMap，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。 LinkedHashMap的存储结构LinkedHashMap中加入了一个head头结点，将所有插入到该LinkedHashMap中的Entry按照插入的先后顺序（accessOrder标志位默认为false）依次加入到以head为头结点的双向循环链表的尾部。 LinkedHashMap实际上就是HashMap和LinkedList两个集合类的存储结构的结合。在LinkedHashMapMap中，所有put进来的Entry都保存在如图所示的哈希表中，但它又额外定义了一个以head为头结点的空的双向循环链表，每次put进来Entry，除了将其保存到对哈希表中对应的位置上外，还要将其插入到双向循环链表的尾部。 先讲述LRU算法 基于LinkedHashMap实现LRU Cache 用LinkedHashmap实现LRU算法，就要覆写方法removeEldestEntry。该方法默认返回false，我们一般在用LinkedHashMap实现LRU算法时，要覆写该方法，一般的实现是，当设定的内存（这里指节点个数）达到最大值时，返回true，这样put新的Entry（该Entry的key在哈希表中没有已经存在）时，就会调用removeEntryForKey方法，将最近最少使用的节点删除（head后面的那个节点，实际上是最近没有使用）。 LinkedHashMap是如何实现LRU的。首先，当accessOrder为true时，才会开启按访问顺序排序的模式，才能用来实现LRU算法。我们可以看到，无论是put方法还是get方法，都会导致目标Entry成为最近访问的Entry，因此便把该Entry加入到了双向链表的末尾（get方法通过调用recordAccess方法来实现，put方法在覆盖已有key的情况下，也是通过调用recordAccess方法来实现，在插入新的Entry时，则是通过createEntry中的addBefore方法来实现），这样便把最近使用了的Entry放入到了双向链表的后面，多次操作后， 双向链表前面的Entry便是最近没有使用的，这样当节点个数满的时候，删除的最前面的Entry(head后面的那个Entry)便是最近最少使用的Entry。 自己描述的测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*LRU是Least Recently Used 近期最少使用算法。 *通过HashLiekedMap实现LRU的算法的关键是，如果map里面的元素个数大于了缓存最大容量，则删除链表头元素 */ /*public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder) *LRU参数参数： *initialCapacity - 初始容量。 *loadFactor - 加载因子（需要是按该因子扩充容量）。 9. *accessOrder - 排序模式( true) - 对于访问顺序（get一个元素后，这个元素被加到最后，使用了LRU 最近最少被使用的算法），对于插入顺序，则为 false,可以不断加入元素。 */ /*相关思路介绍： * 当有一个新的元素加入到链表里面时，程序会调用LinkedHahMap类中Entry的addEntry方法， *而该方法又会 会调用removeEldestEntry方法，这里就是实现LRU元素过期机制的地方， * 默认的情况下removeEldestEntry方法只返回false，表示可以一直表链表里面增加元素，在这个里 *修改一下就好了。 * */ /* 测试数据： 11 7 0 7 1 0 1 2 1 2 6 */ import java.util.*; public class LRULinkedHashMap&lt;K,V&gt; extends LinkedHashMap&lt;K,V&gt;&#123; private int capacity; //初始内存容量 LRULinkedHashMap(int capacity)&#123; //构造方法，传入一个参数 super(16,0.75f,true); //调用LinkedHashMap，传入参数 this.capacity=capacity; //传递指定的最大内存容量 &#125; @Override public boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest)&#123; //，每加入一个元素，就判断是size是否超过了已定的容量 System.out.println("此时的size大小="+size()); if((size()&gt;capacity)) &#123; System.out.println("超出已定的内存容量，把链表顶端元素移除："+eldest.getValue()); &#125; return size()&gt;capacity; &#125; public static void main(String[] args) throws Exception&#123;//方便实例，直接将异常抛出 Scanner cin = new Scanner(System.in); System.out.println("请输入总共内存页面数： "); int n = cin.nextInt(); Map&lt;Integer,Integer&gt; map=new LRULinkedHashMap&lt;Integer, Integer&gt;(n); System.out.println("请输入按顺序输入要访问内存的总共页面数： "); int y = cin.nextInt(); System.out.println("请输入按顺序输入访问内存的页面序列： "); for(int i=1;i&lt;=y;i++) &#123; int x = cin.nextInt(); map.put(x, x); &#125; System.out.println("此时内存中包含的页面数是有:"); //遍历此时内存中的页面并输出 for(java.util.Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet())&#123; System.out.println(entry.getValue()); &#125; &#125; &#125; 下面我们来分析LinkedHashMap的源代码。 LinkedHashMap成员变量LinkedHashMap采用的hash算法和HashMap相同，但它重新定义了数组中保存的元素Entry，该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上又构成了双向链接列表。 :file:java/util/LinkedHashMap.java12345678910111213141516171819//双向循环链表的头结点，整个LinkedHashMap中只有一个header， //（此链表不同于HashMap里面的那个next链表） //它将哈希表中所有的Entry贯穿起来，header中不保存key-value对，只保存前后节点的引用 private transient Entry&lt;K,V&gt; header; //双向链表中元素排序规则的标志位。 //accessOrder为false，表示按插入顺序排序 //accessOrder为true，表示按访问顺序排序 private final boolean accessOrder; /** * LinkedHashMap的Entry元素。 * 继承HashMap的Entry元素，又保存了其上一个元素before和下一个元素after的引用。 */ private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; …… //Entry类涉及到的方法，下面会继续分析 &#125; 构造函数:file:java/util/LinkedHashMap.java123456789101112131415161718192021222324252627282930313233343536373839// 构造方法1，构造一个指定初始容量和加载因子的、按照插入顺序的LinkedList //加载因子取默认的0.75f public LinkedHashMap(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor); accessOrder = false; &#125; // 构造方法2，构造一个指定初始容量的LinkedHashMap，取得键值对的顺序是插入顺序 //加载因子取默认的0.75f public LinkedHashMap(int initialCapacity) &#123; super(initialCapacity); accessOrder = false; &#125; // 构造方法3，用默认的初始化容量和加载因子创建一个LinkedHashMap，取得键值对的顺序是插入顺序 //加载因子取默认的0.75f public LinkedHashMap() &#123; super(); accessOrder = false; &#125; // 构造方法4，通过传入的map创建一个LinkedHashMap，容量为默认容量（16）和 //(map.zise()/DEFAULT_LOAD_FACTORY)+1的较大者，加载因子为默认值0.75 public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; super(m); accessOrder = false; &#125; // 构造方法5，根据指定容量、加载因子和指定链表中的元素排序的规则 创建一个LinkedHashMap public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder; &#125; 我们已经知道LinkedHashMap的Entry元素继承HashMap的Entry，提供了双向链表的功能。在HashMap的构造器中，最后会调用init()方法，进行相关的初始化，这个方法在HashMap的实现中是空方法(感叹模板模式的精妙！)，只是提供给子类实现相关的初始化调用。LinkedHashMap重写了init()方法，在调用父类的构造方法完成构造后，进一步实现了对其元素Entry的初始化操作。分析init()方法，的确是对header进行了初始化，并构造成一个双向循环链表（和LinkedList的存储结构是一样的）。 file:java/util/LinkedHashMap.java1234void init() &#123; header = new Entry&lt;K,V&gt;(-1, null, null, null); header.before = header.after = header; &#125; 元素存储LinkedHashMap重写了父类HashMap的put方法调用的子方法void addEntry(int hash, K key, V value, int bucketIndex) 和void createEntry(int hash, K key, V value, int bucketIndex)，提供了自己特有的双向链接列表的实现。 :file:java/util/LinkedHashMap.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//覆写HashMap中的addEntry方法，LinkedHashmap并没有覆写HashMap中的put方法， //而是覆写了put方法所调用的addEntry方法和recordAccess方法， //put方法在插入的key已存在的情况下，会调用recordAccess方法， //在插入的key不存在的情况下，要调用addEntry插入新的Entry void addEntry(int hash, K key, V value, int bucketIndex) &#123; //创建新的Entry，并插入到LinkedHashMap中 createEntry(hash, key, value, bucketIndex); //双向链表的第一个有效节点（header后的那个节点）为近期最少使用的节点 Entry&lt;K,V&gt; eldest = header.after; //如果有必要，则删除掉该近期最少使用的节点， //这要看对removeEldestEntry的覆写,由于默认为false，因此默认是不做任何处理的。 if (removeEldestEntry(eldest)) &#123; removeEntryForKey(eldest.key); &#125; else &#123; //超过阈值，扩容到原来的2倍 if (size &gt;= threshold) resize(2 * table.length); &#125; &#125; void createEntry(int hash, K key, V value, int bucketIndex) &#123; HashMap.Entry&lt;K,V&gt; old = table[bucketIndex]; Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(hash, key, value, old); table[bucketIndex] = e; // 调用元素的addBrefore方法，将元素加入到哈希、双向链接列表。 //每次插入Entry时，都将其移到双向链表的尾部， //这便会按照Entry插入LinkedHashMap的先后顺序来迭代元素， //同时，新put进来的Entry是最近访问的Entry，把其放在链表末尾，符合LRU算法的实现 e.addBefore(header); size++; &#125; //双向循环立链表中，将当前的Entry插入到existingEntry的前面 private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; &#125; //该方法默认返回false，我们一般在用LinkedHashMap实现LRU算法时， //要覆写该方法，一般的实现是，当设定的内存（这里指节点个数）达到最大值时，返回true， //这样put新的Entry（该Entry的key在哈希表中没有已经存在）时， //就会调用removeEntryForKey方法，将最近最少使用的节点删除（head后面的那个节点，实际上是最近没有使用）。 protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false; &#125; &#125; 元素读取LinkedHashMap重写了父类HashMap的get方法。由于的链表的增加、删除操作是常量级的，性能不会带来较大损失。LinkedHashMap 最牛逼的地方在于recordAccess()方法。 :java/util/LinkedHashMap.java first_line:400 123456789101112131415161718192021222324252627282930//覆写HashMap中的get方法，通过getEntry方法获取Entry对象。 //注意这里的recordAccess方法， //如果链表中元素的排序规则是按照插入的先后顺序排序的话，该方法什么也不做， //如果链表中元素的排序规则是按照访问的先后顺序排序的话，则将e移到链表的末尾处。 public V get(Object key) &#123; // 调用父类HashMap的getEntry()方法，取得要查找的元素。 Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key); if (e == null) return null; // 记录访问顺序。 e.recordAccess(this); return e.value; &#125; //覆写HashMap中的recordAccess方法（HashMap中该方法为空）， //当调用父类的put方法，在发现插入的key已经存在时，会调用该方法， //调用LinkedHashmap覆写的get方法时，也会调用到该方法， //该方法提供了LRU算法的实现，它将最近使用的Entry放到双向循环链表的尾部， //accessOrder为true时，get方法会调用recordAccess方法 //put方法在覆盖key-value对时也会调用recordAccess方法 //它们导致Entry最近使用，因此将其移到双向链表的末尾 void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; //如果链表中元素按照访问顺序排序，则将当前访问的Entry移到双向循环链表的尾部， //如果是按照插入的先后顺序排序，则不做任何事情。 if (lm.accessOrder) &#123; lm.modCount++; remove();//移除当前访问的Entry addBefore(lm.header);//将当前访问的Entry插入到链表的尾部 &#125; &#125; 元素删除LinkedHashMap没有重写remove(Object key)方法，重写了被remove调用的recordRemoval方法，再一次感叹模板方法模式的精妙！HahsMap remove(Object key)把数据从横向数组 * 竖向next链表里面移除之后（就已经完成工作了，所以HashMap里面recordRemoval是空的实现调用了此方法,但在LinkedHashMap里面，还需要移除header链表里面Entry的after和before关系。 元素遍历:file:java/util/LinkedHashMap.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//迭代器 private abstract class LinkedHashIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; Entry&lt;K,V&gt; nextEntry = header.after; Entry&lt;K,V&gt; lastReturned = null; /** * The modCount value that the iterator believes that the backing * List should have. If this expectation is violated, the iterator * has detected concurrent modification. */ int expectedModCount = modCount; public boolean hasNext() &#123; return nextEntry != header; &#125; public void remove() &#123; if (lastReturned == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); LinkedHashMap.this.remove(lastReturned.key); lastReturned = null; expectedModCount = modCount; &#125; //从head的下一个节点开始迭代 Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (nextEntry == header) throw new NoSuchElementException(); Entry&lt;K,V&gt; e = lastReturned = nextEntry; nextEntry = e.after; return e; &#125; &#125; //key迭代器 //看出这三个类都很简单，只有一个next()方法，next()方法也只是去调用LinkedHashIterator类中相应的方法 private class KeyIterator extends LinkedHashIterator&lt;K&gt; &#123; public K next() &#123; return nextEntry().getKey(); &#125; &#125; //value迭代器 private class ValueIterator extends LinkedHashIterator&lt;V&gt; &#123; public V next() &#123; return nextEntry().value; &#125; &#125; //Entry迭代器 private class EntryIterator extends LinkedHashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; &#125; 总结1.LinkedHashMap继承自HashMap，具有HashMap的大部分特性，比如支持null键和值，默认容量为16，装载因子为0.75，非线程安全等等； 2.LinkedHashMap通过设置accessOrder控制遍历顺序是按照插入顺序还是按照访问顺序。当accessOrder为true时，可以利用其完成LRU缓存的功能； 3.LinkedHashMap内部维护了一个双向循环链表，并且其迭代操作时通过链表完成的，而不是去遍历hash表。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现数字金额转换成汉字大写金额]]></title>
    <url>%2FJava%2F2019%2F05%2F15%2FJava-Number-BigChinese%2F</url>
    <content type="text"><![CDATA[我们经常在做项目的财务报表，需要打印发票等情况时需要用到小写的财务金额要转换成汉字的大写金额，下面就是实现该功能的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.lang.Math;/***通用型金钱转换类**/public class Money &#123; private String HanDigiStr[] = new String[] &#123; "零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖" &#125;; private String HanDiviStr[] = new String[] &#123; "", "拾", "佰", "仟", "万", "拾", "佰", "仟", "亿", "拾", "佰", "仟", "万", "拾", "佰", "仟", "亿", "拾", "佰", "仟", "万", "拾", "佰", "仟" &#125;; /**- @param NumStr 输入字符串必须正整数，只允许前导空格(必须右对齐)，不宜有前导零- @return */ String PositiveIntegerToHanStr(String NumStr) &#123; String RMBStr = "";boolean lastzero = false;boolean hasvalue = false; // 亿、万进位前有数值标记int len, n;len = NumStr.length();if (len &gt; 15) return "数值过大!";for (int i = len - 1; i &gt;= 0; i--) &#123; if (NumStr.charAt(len - i - 1) == ' ') continue; n = NumStr.charAt(len - i - 1) - '0'; if (n &lt; 0 || n &gt; 9) return "输入含非数字字符!"; if (n != 0) &#123; if (lastzero) RMBStr += HanDigiStr[0]; // 若干零后若跟非零值，只显示一个零 // 除了亿万前的零不带到后面 // if( !( n==1 &amp;&amp; (i%4)==1 &amp;&amp; (lastzero || i==len-1) ) ) // // 如十进位前有零也不发壹音用此行 if (!(n == 1 &amp;&amp; (i % 4) == 1 &amp;&amp; i == len - 1)) // 十进位处于第一位不发壹音 RMBStr += HanDigiStr[n]; RMBStr += HanDiviStr[i]; // 非零值后加进位，个位为空 hasvalue = true; // 置万进位前有值标记 &#125; else &#123; if ((i % 8) == 0 || ((i % 8) == 4 &amp;&amp; hasvalue)) // 亿万之间必须有非零值方显示万 RMBStr += HanDiviStr[i]; // “亿”或“万” &#125; if (i % 8 == 0) hasvalue = false; // 万进位前有值标记逢亿复位 lastzero = (n == 0) &amp;&amp; (i % 4 != 0);&#125;if (RMBStr.length() == 0) return HanDigiStr[0]; // 输入空字符或"0"，返回"零"return RMBStr; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Integer-To-Roman]]></title>
    <url>%2FLeetocode%2F2019%2F05%2F15%2FInteger-To-Roman%2F</url>
    <content type="text"><![CDATA[Leettcode 第12题 Given an integer, convert it to a roman numeral.The number is guaranteed to be within the range from 1 to 3999. 1234567891011121314151617181920class Solution &#123; public String intToRoman(int num) &#123; if(num &lt;= 0) &#123; return ""; &#125; int[] nums = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;; String[] symbols = &#123;"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"&#125;; StringBuilder res = new StringBuilder(); int digit=0; while (num &gt; 0) &#123; int times = num / nums[digit]; num -= nums[digit] * times; for ( ; times &gt; 0; times--) &#123; res.append(symbols[digit]); &#125; digit++; &#125; return res.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Leetocode</category>
      </categories>
      <tags>
        <tag>Leetocode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles和Shadowsocks共同使用]]></title>
    <url>%2FStudy%2F2019%2F05%2F14%2FCharles-Shadowsocks%2F</url>
    <content type="text"><![CDATA[一个是抓包利器Charles，一个是翻墙神器Shadowcocks，两个工具都是客户端开发必备的，但使用的时候有个尴尬的地方，就是二者不能同时使用。终于试出了二者同时使用(仅限全局模式下)的方法记录一下。 不能同时使用的原因是，二者都通过修改系统的代理来实现抓包或翻墙，打开任一应用的时候都可以观察到“系统偏好设置 - 网络 - 高级 - 代理栏”有修改。Shadowsocks覆盖了Charles的配置的话，使用Shadowsocks时自然用Charles抓不到包。 然而Charles是可以设置外部代理(External Proxy)的，解决方案就是将Charles的外部代理设置为Shadowsocks的Http代理。 步骤：1. 查看Shadowsocks的Http代理。Shadowsocks的Mac客户端推荐使用最新版本的 ShadowsocksX-NG （原ShadowsocksX的重写版本），Github上可直接下载最新版安装包。 启动ShadowsocksX-NG后，在菜单栏点击“Http代理设置”可查看代理的地址和端口：127.0.0.1:1087 _ 2.将Shadowsocks设置成全局模式。在ShadowsocksX-NG菜单“代理”下选择“全局模式”（使用”PAC自动模式”Charles同样抓不到包） 3. 设置Charles的外部代理。启动Charles，点击菜单栏的“Proxy - External Proxy Settings”， 勾选“Use external proxy servers”，并填上刚才查到的代理地址和端口，保存。 4. 重启Charles，能正常抓包。注意事项： 该方法仅对全局模式有效，自动代理模式抓不到包 设置完成后抓不到包，请依次检查： 是否打开了ShadowsocksX-NG，能否正常翻墙 ShadowsocksX-NG是否勾选全局模式 Charles的Proxy菜单下是否勾选External Proxy Settings External Proxy Settings里的地址和端口设置是否与ShadowsocksX-NG的“Http代理设置”里显示的一致 重启Charles 过段时间后上网不正常，报错“Failed to connect to external proxy”等，则可能是Charles设置打开了External Proxy Settings，却没有启动ShadowsocksX-NG。解决方法：启动ShadowsocksX-NG，或者取消Charles的Proxy栏下“External Proxy Settings”选项]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>Chat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac_Install_Maven]]></title>
    <url>%2FJava%2F2019%2F05%2F06%2FMac_Install_Maven%2F</url>
    <content type="text"><![CDATA[记录自己给Mac安装maven的一天 自己最开始给自己根据网上的路子走了一遍，但是都是报错,报的错是如下两种 12345localhost:opt doude$ mvn -v Error: JAVA_HOME is not defined correctly.We cannot execute /Library/Java/JavaVirtualMachines/jdk1.8.0_211/Contents/Home/bin/java# 1234567localhost:~ doude$ mvn -v The JAVA_HOME environment variable is not defined correctlyThis environment variable is needed to run this programNB: JAVA_HOME should point to a JDK not a JRE 历经更换maven版本，更换maven放置的目录 但是最后通过更改 ~/.bash_profile 1234567export JAVA_HOME=$(/usr/libexec/java_home)export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jreexport PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 如上把JAVA_HOME进行了更改 12345678910111213 localhost:opt doude$ mvn -v **Apache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)**Maven home: /opt/apache-maven-3.5.0Java version: 1.8.0_211, vendor: Oracle CorporationJava home: /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jreDefault locale: zh_CN, platform encoding: UTF-8OS name: "mac os x", version: "10.14.4", arch: "x86_64", family: "mac" 终于出来了自己想要的模样 给你一个可以下载previous版本的maven库http://archive.apache.org/dist/maven/maven-3/3.3.3/binaries/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Design-Patterns-Decorator]]></title>
    <url>%2FGood-Quality-Code%2F2019%2F04%2F28%2FDesign-Patterns-Decorator%2F</url>
    <content type="text"><![CDATA[课程概述装饰器模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 某一天隔壁老王赤果果地来到百货商店，打算给自己买一套装备，武装到牙齿。他买了衣服、裤子和帽子，于是老王这样做： 12345678910public class LaoWang &#123; public void show()&#123; System.out.println("我穿上衣服，累计花费100元"); System.out.println("我穿上裤子，累计花费250元"); System.out.println("我穿上帽子，花费300元"); //........ //........ &#125;&#125; 但老王很快发现了问题，每买一件装备都要修改一次 show() 方法，违背了开闭原则。在前面的内容中已经解释过开闭原则：对扩展开放、对修改关闭。每增加一件装备都相当于扩展了一个功能，我们不应该用修改原方法的方式来扩展功能。 机智的老王学过设计模式，很快就想到了使用装饰器模式，装饰器模式动态地把功能附加到对象上。 装饰器模式类图： 观察上图，装饰器模式中主要有两个角色： 装饰器； 被装饰的对象。 用老王买装备的例子来说，老王就是被装饰的对象，而衣服、裤子、帽子等就是装饰器。 装饰器和被装饰的对象有两个特点，也是装饰器模式的关键： 他们实现同一个接口； 装饰器中使用了被装饰的对象。 下面我们来简单地实现上面的例子。 老王（ 被装饰的对象 ）： 123456789101112131415161718192021public interface Person &#123; /** * 计算累计消费 * @return */ public Double cost(); public void show();&#125;public class LaoWang implements Person&#123; @Override public Double cost() &#123; return 0.0; //赤果果的时候累计消费为0 &#125; @Override public void show() &#123; System.out.println("我是赤果果的老王"); &#125;&#125; 装饰器超类，和被装饰的对象实现同一个接口 Person ： 123456789public abstract class ClothesDecorator implements Person &#123; //装饰器中要使用被装饰器的对象，构造方法中传入 protected Person person; public ClothesDecorator(Person person)&#123; this.person = person; &#125;&#125; 具体的装饰，夹克和帽子： 1234567891011121314151617181920212223242526272829303132333435public class Jacket extends ClothesDecorator &#123; public Jacket(Person person) &#123; super(person); &#125; @Override public void show() &#123; person.show(); System.out.println("穿上夹克，累计消费" + this.cost()); &#125; @Override public Double cost() &#123; return person.cost() + 100; //夹克100元 &#125;&#125;public class Hat extends ClothesDecorator &#123; public Hat(Person person) &#123; super(person); &#125; @Override public void show() &#123; //执行已有功能 person.show(); //此处是附加的功能 System.out.println("戴上帽子，累计消费" + this.cost()); &#125; @Override public Double cost() &#123; return person.cost() + 50; //帽子50元 &#125;&#125; 测试： 12345678Person laowang = new LaoWang();//穿上夹克laowang = new Jacket(laowang);//戴上帽子laowang = new Hat(laowang);laowang.show();System.out.println("买单，老王总共消费："+laowang.cost()); 效果： 用了装饰器模式，老王还想穿裤子、鞋子，只要分别创建裤子、鞋子的装饰类就可以动态地穿上了，而不用修改已写好的类，深入贯彻落实了开闭原则。 使用装饰器模式的几个关键点： 装饰器和被装饰类要实现同一个接口（ 实际开发中也可能用继承 ）。 装饰器中的方法可以调用被装饰对象提供的方法，以此实现功能累加的效果，例如，夹克装饰器和帽子装饰器中调用了 person.cost() + xx 实现累计消费金额的累加。 实际案例Java 中的 IO 流在学习 Java 基础的过程中，学习 IO 流是必不可少的，同时这也是最令人头疼。我们先来简单地写一下 IO 流的应用。 先准备一个文本文件： 12hello world!I am laowang 用输入流读取内容： 123456DataInputStream in = new DataInputStream(new FileInputStream("test.txt"));String str;while((str = in.readLine()) != null)&#123; System.out.println(str);&#125;in.close(); 结果： 笔者刚入门 Java 的时候，学到上面的代码，其实还算简单，但后来又了解到还有 BufferedInputStream 、StringBufferInputStream 等等。许多 InputStream 子类互相嵌套，除了输入流，还有输出流 OutputStream ，以及各种字符流 Writter 和 Reader ，庞大的 IO 流家族简直令人崩溃。 后来看了下 IO 流的族谱，总算对此有了个大概的了解： 上图是 InputStream 家族，OutputStream 也是类似。通过上图，对整体结构清晰了不少，但是对 new DataInputStream(new FileInputStream(“test.txt”)); 这种调用方式还是一知半解，不明白为什么这样嵌套？到底谁嵌套谁？ 直到学习了装饰器模式，赫然发现 IO 家族族谱怎么长得这么像装饰器模式的类图？不妨回到本课程开头将装饰器类图和 InputStream 族类图对比一下，你会发现 InputStream 类其实就是被装饰对象的超类，FileInputStream 、StringBufferInputStream 等就是要被装饰的对象，FilterInputStream 以及其子类就是装饰器。 回顾老王穿衣服的代码： 123Person laowang = new LaoWang();//穿上夹克laowang = new Jacket(laowang); 换种写法： 1Person laowang = new Jacket(new LaoWang()); 是不是和 new DataInputStream(new FileInputStream(“test.txt”)); 一模一样？ 学到这里，有种豁然开朗的感觉，原来 IO 流根本不难，只要了解其家族成员，谁嵌套谁的问题也就迎刃而解。 根据装饰器模式，我们来自定义一个装饰器，将所有英文字母转换为空格： 123456789101112131415161718public class CharacterInputStream extends FilterInputStream &#123; public CharacterInputStream(InputStream in) &#123; super(in); &#125; @Override public int read() throws IOException &#123; //ASCLL码对照,[97,122] 和 [65,90]是英文字母 int c = super.read(); if(c &gt;= 97 &amp;&amp; c &lt;= 122 || c &gt;= 65 &amp;&amp; c &lt;= 90)&#123; return 32; //32是空格 &#125;else&#123; return c; &#125; &#125;&#125; 测试，准备一个文本： 12345678910hello/world!I am*&amp;^ laowang*632DataInputStream in = new DataInputStream( new CharacterInputStream( new FileInputStream("test.txt")));String str;while((str = in.readLine()) != null)&#123; System.out.println(str);&#125; 结果： 文本中的英文字母成功地被转换成了空格。 IO 家族中的输出流、字符输入输出流等都是同样的道理，此处不再详述。 JSON 格式化日志打印日志是开发中最常做的事，是调试 bug 最重要的手段之一。 有一天隔壁老王公司的系统出了个问题，老王查看日志时，其中有一段业务日志是一个 JSON 字符串，内容是用户银行卡数据： 老王发现大量的 JSON 日志堆积在一起时，很难用肉眼快速筛选中自己想要的数据。怎么办？ 难道每次都要把日志内容复制出来用工具转换一下吗？太麻烦了。于是老王就想如果打印日志的时候能够自动将 JSON 格式的日志格式化显示就好了。 可是老王用的是 Apache 的 Log4j 打印日志，不可能去改源码，咋整？经验丰富的老王想到了装饰器模式，动态地给日志增加功能。 首先我们需要一个将 JSON 字符串格式化的工具类，下方格式化 JSON 的具体代码逻辑可以不看，与装饰器模式本身无关，笔者也是直接从网上复制来的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.qiuzhilin.design.decorator;public class Json &#123; private static String getLevelStr(int level) &#123; StringBuffer levelStr = new StringBuffer(); for (int levelI = 0; levelI &lt; level; levelI++) &#123; levelStr.append("\t"); &#125; return levelStr.toString(); &#125; public static String format(String s)&#123; int level = 0; //存放格式化的json字符串 StringBuffer jsonForMatStr = new StringBuffer(); for(int index=0;index&lt;s.length();index++)//将字符串中的字符逐个按行输出 &#123; //获取s中的每个字符 char c = s.charAt(index); //level大于0并且jsonForMatStr中的最后一个字符为\n,jsonForMatStr加入\t if (level &gt; 0 &amp;&amp; '\n' == jsonForMatStr.charAt(jsonForMatStr.length() - 1)) &#123; jsonForMatStr.append(getLevelStr(level)); &#125; //遇到"&#123;"和"["要增加空格和换行，遇到"&#125;"和"]"要减少空格，以对应，遇到","要换行 switch (c) &#123; case '&#123;': case '[': jsonForMatStr.append(c + "\n"); level++; break; case ',': jsonForMatStr.append(c + "\n"); break; case '&#125;': case ']': jsonForMatStr.append("\n"); level--; jsonForMatStr.append(getLevelStr(level)); jsonForMatStr.append(c); break; default: jsonForMatStr.append(c); break; &#125; &#125; return jsonForMatStr.toString(); &#125;&#125; 重点是装饰类： 123456789101112131415161718192021package cn.qiuzhilin.design.decorator;import org.apache.log4j.Logger;public class JsonFormatLoggerDecorator extends Logger &#123; protected static Logger logger; public JsonFormatLoggerDecorator(Logger logger)&#123; super(JsonFormatLoggerDecorator.class.getName()); JsonFormatLoggerDecorator.logger = logger; &#125; @Override public void error(Object message) &#123; if(message instanceof String)&#123; //严格来说这里要判断是否是json格式 logger.error("\n"+Json.format((String)message)); &#125;else&#123; logger.error(message); &#125; &#125;&#125; 把装饰的过程写到工厂类中： 123456789101112package cn.qiuzhilin.design.decorator;import org.apache.log4j.LogManager;import org.apache.log4j.Logger;public class MyLoggerFactory &#123; public static Logger getLogger(String name)&#123; //此处可以进行多层装饰，给日志增加多个功能 return new JsonFormatLoggerDecorator(LogManager.getLogger(name)); &#125;&#125; 测试： 123456String str= " &#123;\"code\": 0, \"data\": &#123;\"status\": 1,\"number\": \"215646454\",\"account_name\": \"吴系挂\",\"type\":\"中国银行\" ,\"address\": \"某某支行\",\"icon\": \"http://xxx.xxx.xx\"&#125;&#125;";//此处可以写成类静态变量Logger logger = MyLoggerFactory.getLogger(Demo.class.getName());//实际开发时，可以传入对象，在装饰类中将对象转换成json字符串。此处只是测试所以直接传入json字符串logger.error(str); 效果： 除了格式化 JSON，将来老王还能随心所欲地给日志附加其他功能，例如老王觉得日志挤在一起看起来很不舒服，想要给每一条日志都加一行空行，只要写一个装饰类，然后在 MyLoggerFactory 进行装饰即可。 课程总结装饰器模式的作用是动态给对象增加一些功能，而不需要修改对象本身。 优点 扩展功能的方式比较灵活； 每一个装饰器相互独立，需要修改时不会互相影响。 缺点多层装饰比较复杂，就像 Java 的 IO 流，对于初学者不友好。]]></content>
      <categories>
        <category>Good-Quality-Code</category>
      </categories>
      <tags>
        <tag>Design-Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Design-Patterns-Strategy]]></title>
    <url>%2FGood-Quality-Code%2F2019%2F04%2F27%2FDesign-Patterns-Strategy%2F</url>
    <content type="text"><![CDATA[课程概述策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 一般情况下我们是将一种行为写成一个类方法，比如计算器类中有加、减、乘、除四种方法，而策略模式则是将每一种算法都写成一个类，然后动态地选择使用哪一个算法。 这里所说的算法并不是指 “ 冒泡排序算法 ” 、“ 搜索算法 ” 之类的算法，它可以是一段代码、一个请求、一个业务操作。 策略模式如图： 从上图可以看到，我们将操作封装到类中，他们实现了同一个接口，然后在 Context 中调用。 这里我们举一个计算器的例子： 此例中，为加法和减法分别创建了一个类。 其实策略不一定要命名为 Strategy ，Context 不一定要叫 Context ，可以根据实际情况自己命名，在计算器的例子中，你如果非要命名为 Strategy 和 Context ，反而让人产生疑惑。 实际代码也很简单，具体如下。 Operation 接口： 123public interface Operation &#123; public int doOperation(int num1, int num2);&#125; 两个实现类 —— 加法和减法： 12345678910111213public class OperationAdd implements Operation&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 + num2; &#125;&#125;public class OperationSub implements Operation &#123; @Override public int doOperation(int num1, int num2) &#123; return num1 - num2; &#125;&#125; 计算器类： 1234567891011public class Calculator &#123; private Operation operation; public void setOperation(Operation operation)&#123; this.operation = operation; &#125; public int doOperation(int num1, int num2)&#123; return this.operation.doOperation(num1,num2); &#125;&#125; 使用： 1234Calculator calculator = new Calculator();calculator.setOperation(new OperationAdd());int result = calculator.doOperation(1,2);System.out.println(result); 使用计算器类时，如果要进行加法运算，就 New 一个加法类传入，减法也是同理。 看到这里，相信大家一定会有疑惑，为什么要把加、减、乘、除四则运算分别封装到类中？直接在 Calculator 中写 add() 、sub() 等方法不是更方便吗？甚至如果要添加其他的运算方法，每次都要创建一个类，反而更麻烦。 的确，用了策略模式之后代码比普通写法多了一些，但是这里假设一种场景：把写好的计算器代码打包好作为一个库发布出去给其他人用，其他人发现你的计算器中只有加、减、乘、除四个方法，而他想增加平方、开方等功能，怎么办？ 如果是用普通写法写的计算器，想要增加功能唯一的办法就是修改你写好的 Calculator ，增加平方和开方两个 method 。 可是你提供的是一个 jar 包啊，jar 包，jar…jar…jar…jar…包…… 就算你提供的是源码，你希望其他人可以随意修改你写好的代码吗？一般我们发布出去的开源框架或库都是经过千锤百炼、经过测试的代码，其他人随意修改我们的源码很容易产生不可预知的错误。 如果你用的是策略模式，那么其他人想要增加平方或开平方功能，只需要自己定义一个类实现你的 Operation 接口，然后调用 calculator.setOperation(new 平方类()); 即可。 看到这里相信你已经对策略模式有了一定的好感，甚至惊叹一声：哇，还有这种操作？ 顺便提一嘴，这里很好的体现了一个设计模式的基本原则：开闭原则。开闭原则说的是 ” 对修改关闭、对扩展开放 “ 。对修改关闭就是不希望别人修改我们的代码，此路不通，对扩展开放就是希望别人以扩展的方式增加功能，策略模式把开闭原则体现得淋漓尽致。 实际案例主题隔壁老王准备开发一个客户端框架，允许其他的开发者进行二次开发，其中有一个更换主题的功能，开发者们可以自己定义主题。老王很快就想到了策略模式，并且提供了一个默认主题 DefaultTheme ： 代码： 1234567891011121314151617181920212223public interface Theme &#123; public void showTheme();&#125;public class DefaultTheme implements Theme &#123; @Override public void showTheme() &#123; //此处设置主题颜色，背景，字体等 System.out.println("显示默认主题"); &#125;&#125;public class ThemeManager &#123; private Theme theme; public void setTheme(Theme theme)&#123; this.theme = theme; &#125; public void showTheme()&#123; this.theme.showTheme(); &#125;&#125; 使用： 123ThemeManager themeManager = new ThemeManager();themeManager.setTheme(new DefaultTheme());themeManager.showTheme(); 看完更换主题的案例代码，你会发现跟计算器惊人地相似，没错，所谓设计模式就是前人总结出来的武功套路，经常可以直接套用。当然也要灵活地根据实际情况进行修改，设计模式想要传达给我们的更多的是一种编程思想。 这里还有一个小窍门： 1themeManager.setTheme(new DefaultTheme()); 在这里老王 New 一个默认主题对象，如果其他开发者加了主题，还要修改这行代码，New 开发者自定义的主题对象。根据开闭原则，我们不希望其他人修改我们的任何一行代码，否则拔刀相见。老王机智地将主题的包名和类名写到了配置文件中，利用 Java 的反射机制动态生成主题对象，因此更换主题也只要修改配置文件即可。 ShiroShiro 是 Java 界最著名的权限控制框架之一，相信大家都不陌生。在 Shiro 中，我们可以创建多个权限验证器进行权限验证，如验证器 A、验证器 B、验证器 C，三个验证器可以同时生效。 那么就产生了一个问题，如果验证器 A 验证通过，B 验证不通过，C 验证通过，这种情况怎么办？到底算当前用户验证通过还是不通过呢？ Shiro 给我们提供了三种验证策略，就像老王默认提供了一种主题一样： AtLeastOneSuccessfulStrategy ：只要有一个验证通过，那么最终验证结果就是通过。 FirstSuccessfulStrategy ：只有第一个成功地验证的 Realm 返回的信息将被使用，所有进一步的 Realm 将被忽略，如果没有一个验证成功，则整体尝试失败。 AllSucessfulStrategy ：所有验证器都必须验证成功。 如果你不熟悉 Shiro ，看不懂上面三种策略的含义，没关系，本课程讲的是设计模式，而不是 Shiro 的使用，你只要知道 Shiro 默认为我们提供了三种策略即可。 作为开发者，在使用 Shiro 的时候，Shiro 默认的策略未必符合我们的需求，比如我们要求三个验证器中通过两个才算通过，怎么办？很简单，Shiro 这里用的也是策略模式，我们只要自定义一个 MyAuthenticationStrategy 继承 Shiro 的 AbstractAuthenticationStrategy 。咦？前面不是说实现接口吗，这里怎么是继承？变通，要懂得变通。设计模式不是一成不变的，重要的是这种编程思想。 然后在 MyAuthenticationStrategy 实现父类要求的方法，再修改配置文件将当前验证策略改为你定义的验证策略： 1authcStrategy = 你的包名.MyAuthenticationStrategy 课程总结优点讲完上面的例子，优点已经十分明显了，那就是遵循了开闭原则，扩展性良好。 缺点 随着你的策略增加，你的类也会越来越多。 所有的策略类都要暴露出去，所以如果你在实际开发中使用了策略模式，一定要记得写好文档让你的伙伴们知道已有哪些策略。就像 Shiro 默认提供了三种验证策略，就必须在文档中写清楚，否则我们根本不知道如何使用。 当然，权衡利弊，跟优点比起来，这些缺点都不算事儿。]]></content>
      <categories>
        <category>Good-Quality-Code</category>
      </categories>
      <tags>
        <tag>Design-Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo下的代码高亮及其扩展修改]]></title>
    <url>%2FHexo%2F2019%2F04%2F26%2Fhexo-next-code-hightlight%2F</url>
    <content type="text"><![CDATA[​ 本文主要记录一下，修改Hexo下语法高亮的各种用法，修改后的语法可以快速设置多种样式，主要功能如： 设置语法语言 设置标题 是否显示行号 设置起始行号 选定行号标记 设置代码添加删除标记 （新增） 设置跳转超级链接 格式总览主要功能如上，都是自带功能，更重要的是只是想在后直接实现设置，不想使用{ % ... % }去实现这些功能。 格式 123​```[language] [:title] [lang:language] [line_number:(true|false)] [first_line:number] [mark:#,#-#] [diff:true|false] [url:http...]code snippet​ 12- 自定义 ​12code snippet​ 12345- 效果 ``` sam code snippet 使用方法 设置语法语言 格式 123​``` language //注意 语言类型 需要写在其他定义之前code snippet​ 12- 样例 ​123456public Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl("Hello World"); &#125;&#125;​ 12- 效果 public Class HelloWorldClass(){ public static void main(String[] args){ System.Out.printl(&quot;Hello World&quot;); } } 1234### 设置标题- 格式 ​ link12code snippet ​ 12- 样例 ​xia/HelloWorldClass.javalink123456public Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl(&quot;Hello World&quot;); &#125;&#125;​ 12- 效果 file:///D:/qiuzhilin xia/HelloWorldClass.java public Class HelloWorldClass(){ public static void main(String[] args){ System.Out.printl(“Hello World”); } } 1234### &lt;span id = "jump"&gt;是否显示行号&lt;/span&gt;- 格式 ​ link12code snippet​ 12- 样例 ​line_number:false 123456public Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl("Hello World"); &#125;&#125;​ 12- 效果 public Class HelloWorldClass(){ public static void main(String[] args){ System.Out.printl(“Hello World”); } } 1234### 设置起始行号- 格式 ​ link12code snippet​ 12- 样例 ​first_line:22 123456public Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl("Hello World"); &#125;&#125;​ 123456789- 效果 ```java public Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl("Hello World"); &#125; &#125; 选定行号标记 格式 123​``` [mark:#,#-#] //#行号，#-#行号范围code snippet​ 12- 样例 ​mark:2,4,8,10-14,18 123456789101112131415161718192021public Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); &#125;&#125;​ 123456789101112131415161718192021222324- 效果 ```java public Class HelloWorldClass()&#123; public static void main(String[] args)&#123; System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); System.Out.printl("Hello World"); &#125; &#125; 设置代码添加删除标记 格式 123​``` [diff:true|false] code snippet​ 12- 样例 ​diff:true 12345678910'use struct';-var name = 'zhu'+var name = 'qiuzhilinxia';function sayHello()&#123;- alert(name);+ console.log(name);&#125;​ 12- 效果 ‘use struct’; var name = ‘zhu’var name = ‘qiuzhilinxia’; function sayHello(){ alert(name); console.log(name); } 123456还有更惊喜的功能，你点击左上角 `复制` 按钮，粘贴出去试试看！只会复制出最新代码哦。### 设置跳转超级链接- 格式 ​download|下载]开头，无download则跳转链接，有则下载内容12code snippet​ 12- 样例 ​url:http://qiuzhilinyule.com/images/avatar.png download12这里会下载我的头像！​ 12- 效果 需要标题 download 这里会下载我的头像！ 1234## 修改代码如果需要实现以上功能，需要更改 `./node_modules/`目录下插件： node_module|–hexo| |–lib| |–plugins| |–filter| |–before_post_render| |–backtick_code_block.js||–hexo-util| |–lib| |–highlight.js1234覆盖以上文件即可，详细不在这里描述了。在添加样式文件即可： themes|–next| |–source| |–css| |–_custom| |–highlight.styl| |–custom.styl //感谢 @maoshengyang 提醒，还需要添加文件引用：@import highlight;1234`custom.styl`中添加样式文件引用： custom.styl @import highlight;1234`theme.styl`中直接添加颜色，可以自己调整颜色（放在这里好控制管理皮肤）： .\themes\next\source\css_common\components\highlight\theme.styl $highlight-diffdeletion = #c7ffd7$highlight-diffaddition = #ffd3d81234也可以这样，这是我的 自己使用的皮肤配色： .\themes\next\source\css_common\components\highlight\theme.styl if $highlight_theme == “custom light” $highlight-figcaptionBK = #eee $highlight-figcaptionFont = #777 $highlight-background = #f8f8f8 $highlight-emphasisBK = #ffffff $highlight-emphasisFont = #111 $highlight-current-line = #efefef $highlight-selection = #d6d6d6 $highlight-foreground = #4d4d4c $highlight-comment = #6eb55e $highlight-red = #c82829 $highlight-orange = #f5871f $highlight-yellow = #eab700 $highlight-green = #718c00 $highlight-aqua = #3e999f $highlight-blue = #4271ae $highlight-purple = #1212a0 $highlight-diffdeletion = #c7ffd7 $highlight-diffaddition = #ffd3d8 $highlight-gutter = { color: #5c5c5c, bg-color: #e7e5dc, right-border-color: #aed581 }`]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadPool]]></title>
    <url>%2FJava%2F2019%2F04%2F24%2FThreadPool%2F</url>
    <content type="text"><![CDATA[首先说说为什么用线程池？创建并开启一个线程开销很大。如果我们每次需要执行任务时重复这个步骤，那将会是一笔巨大的性能开销，这也是我们希望通过多线程解决的问题。为了更好理解创建和开启一个线程的开销，让我们来看一看 JVM 在后台做了哪些事： 出处: ~/深入Java虚拟机/Java线程.java12345678为线程栈分配内存，保存每个线程方法调用的栈帧。 每个栈帧包括本地变量数组、返回值、操作栈和常量池 一些 JVM 支持本地方法，也将分配本地方法栈 每个线程获得一个程序计数器，标识处理器正在执行哪条指令 系统创建本地线程，与 Java 线程对应 和线程相关的描述符被添加到JVM内部数据结构 线程共享堆和方法区 当然，这些步骤的具体细节取决于 JVM 和操作系统。另外，更多的线程意味着更多工作量，系统需要调度和决定哪个线程接下来可以访问资源。线程池通过减少需要的线程数量并管理线程生命周期，来帮助我们缓解性能问题。 本质上，线程在我们使用前一直保存在线程池中，在执行完任务之后，线程会返回线程池等待下次使用。这种机制在执行很多小任务的系统中十分有用。 在web开发中，服务器需要接受并处理请求，所以会为一个请求来分配一个线程来进行处理。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题： 如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。 那么有没有一种办法使执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？ 这就是线程池的目的了。线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。 什么时候使用线程池？ 单个任务处理时间比较短 需要处理的任务数量很大 使用线程池的好处 引用自 ifeve.com/java-thread… 的说明： 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 例如：记创建线程消耗时间 T1，执行任务消耗时间 T2，销毁线程消耗时间 T3 如果 T1 + T3 &gt; T2，那么是不是说开启一个线程来执行这个任务太不划算了！ 正好，线程池缓存线程，可用已有的闲置线程来执行新任务，避免了 T1 + T3 带来的系统开销。 线程池种类再说线程池种类之前，先说一下初始化线程池的几个参数，如果这个参数弄明白了，对于线程池你就基本上就可以了解了。 先来看一下线程池的几个构造函数。 1234567891011121314151617181920212223242526272829303132333435 //五个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)//六个参数的构造函数 -1 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)//六个参数的构造函数 -2 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)//七个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)int corePoolSize =&gt; 该线程池中核心线程数最大值 1. 核心线程 线程池新建线程的时候，如果当前线程总数小于 corePoolSize，则新建的是核心线程，如果超过 corePoolSize，则新建的是非核心线程 核心线程默认情况下会一直存活在线程池中，即使这个核心线程啥也不干 (闲置状态)。 如果指定 ThreadPoolExecutor 的 allowCoreThreadTimeOut 这个属性为 true，那么核心线程如果不干活(闲置状态)的话，超过一定时间(时长下面参数决定)，就会被销毁掉 很好理解吧，正常情况下你不干活我也养你，因为我总有用到你的时候，但有时候特殊情况 (比如我自己都养不起了)，那你不干活我就要把你干掉了 2. 线程总数int maximumPoolSize=&gt; 该线程池中线程总数最大值线程总数 = 核心线程数 + 非核心线程数。 核心线程在上面解释过了，这里说下非核心线程：不是核心线程的线程(别激动，把刀放下…)，其实在上面解释过了。 3. 超时时间long keepAliveTime =&gt; 该线程池中非核心线程闲置超时时长 一个非核心线程，如果不干活(闲置状态)的时长超过这个参数所设定的时长，就会被销毁掉。 如果设置 allowCoreThreadTimeOut = true，则会作用于核心线程 4. 时间单位TimeUnit unit keepAliveTime 的单位，TimeUnit 是一个 枚举类型，其包括： NANOSECONDS ： 1微毫秒 = 1微秒 / 1000MILLISECONDS ： 1毫秒 = 1秒 /1000SECONDS ： 秒MINUTES ： 分HOURS ： 小时DAYS ： 天 5. 队列BlockingQueue workQueue 该线程池中的任务队列：维护着等待执行的 Runnable 对象 当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务 6. 常用的 workQueue 类型 SynchronousQueue：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;线程数达到了maximumPoolSize而不能新建线程&gt;的错误，使用这个类型队列的时候，maximumPoolSize 一般指定成 Integer.MAX_VALUE，即无限大 LinkedBlockingQueue：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了 maximumPoolSize 的设定失效，因为总线程数永远不会超过 corePoolSize ArrayBlockingQueue：可以限定队列的长度，接收到任务的时候，如果没有达到 corePoolSize 的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程 (非核心线程) 执行任务，又如果总线程数到了 maximumPoolSize，并且队列也满了，则发生错误 DelayQueue：队列内元素必须实现 Delayed 接口，这就意味着你传进去的任务必须先实现 Delayed 接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务 7. ThreadFactory创建线程的方式，这是一个接口，你 new 他的时候需要实现他的Thread newThread(Runnable r)方法，一般用不上。 小伙伴应该知道 AsyncTask 是对线程池的封装吧？那就直接放一个 AsyncTask 新建线程池的 threadFactory 参数源码吧： 1234567new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread new Thread(Runnable r) &#123; return new Thread(r,"AsyncTask#"+mCount.getAndIncrement()); &#125;&#125; 这么简单？就给线程起了个名! 8. RejectedExecutionHandler这玩意儿就是抛出异常专用的，比如上面提到的两个错误发生了，就会由这个handler抛出异常，你不指定他也有个默认的 ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。 ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 9. ThreadPoolExecutor 的策略上面介绍参数的时候其实已经说到了 ThreadPoolExecutor 执行的策略，这里给总结一下，当一个任务被添加进线程池时： 1.线程数量未达到corePoolSize，则新建一个线程(核心线程)执行任务 2.线程数量达到了 corePools，则将任务移入队列等待 3.队列已满，新建线程(非核心线程)执行任务 4.队列已满，总线程数又达到了 maximumPoolSize，就会由上面那位星期天 (RejectedExecutionHandler) 抛出异常 常见四种线程池如果你不想自己写一个线程池，那么你可以从下面看看有没有符合你要求的 (一般都够用了)，如果有，那么很好你直接用就行了，如果没有，那你就老老实实自己去写一个吧。 Java 通过 Executors 提供了四种线程池，这四种线程池都是直接或间接配置 ThreadPoolExecutor 的参数实现的，下面我都会贴出这四种线程池构造函数的源码，各位大佬们一看便知！ CachedThreadPool优势： 1.线程数无限制2.有空闲线程则复用空闲线程，若无空闲线程则新建线程3.一定程序减少频繁创建/销毁线程，减少系统开销 创建方法： 1234567ExecutorService cachedThreadPool = Executors.newCachedThreadPool();public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; FixedThreadPool优势： 1.可控制线程最大并发数（同时执行的线程数）2.超出的线程会在队列中等待 1234567891011创建方法：//nThreads =&gt; 最大线程数即maximumPoolSizeExecutorService fixedThreadPool = Executors.newFixedThreadPool(int nThreads);//threadFactory =&gt; 创建线程的方法，这就是我叫你别理他的那个星期六！你还看！ExecutorService fixedThreadPool = Executors.newFixedThreadPool(int nThreads, ThreadFactory threadFactory);源码：public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 2个参数的构造方法源码，不用我贴你也知道他把星期六放在了哪个位置！所以我就不贴了，省下篇幅给我扯皮 ScheduledThreadPool支持定时及周期性任务执行。 123456789101112//创建方法：//nThreads =&gt; 最大线程数即maximumPoolSizeExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(int corePoolSize);//源码：public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;//ScheduledThreadPoolExecutor():public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125; SingleThreadExecutor优势： 1.有且仅有一个工作线程执行任务2.所有任务按照指定顺序执行，即遵循队列的入队出队规则 12345678910 //创建方法： ExecutorService singleThreadPool = Executors.newSingleThreadPool(); //源码： public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125;// 还有一个Executors.newSingleThreadScheduledExecutor()结合了 3 和 4，就不介绍了，基本不用 准确的指定参数大小系统负载参数的设置跟系统的负载有直接的关系，下面为系统负载的相关参数： tasks：每秒需要处理的最大任务数量 tasktime：处理第个任务所需要的时间 responsetime：系统允许任务最大的响应时间，比如每个任务的响应时间不得超过2秒。 参数设置corePoolSize:每个任务需要 tasktime 秒处理，则每个线程每钞可处理 1 / tasktime 个任务。 系统每秒有 tasks 个任务需要处理，则需要的线程数为：tasks / ( 1 / tasktime )，即 tasks * tasktime 个线程数。 假设系统每秒任务数为 100 ~ 1000，每个任务耗时 0.1 秒，则需要 100 0.1 至 1000 0.1，即 10 ~ 100 个线程。 那么 corePoolSize 应该设置为大于 10，具体数字最好根据 8020 原则，即 80 % 情况下系统每秒任务数，若系统80%的情况下第秒任务数小于 200，最多时为 1000，则 corePoolSize 可设置为 20。 queueCapacity:任务队列的长度要根据核心线程数，以及系统对任务响应时间的要求有关。 队列长度可以设置为 ( corePoolSize / tasktime ) responsetime ： ( 20 / 0.1 ) 2 = 400，即队列长度可设置为 400。 队列长度设置过大，会导致任务响应时间过长，切忌以下写法： 1LinkedBlockingQueue queue = new LinkedBlockingQueue(); 这实际上是将队列长度设置为Integer.MAX_VALUE，将会导致线程数量永远为corePoolSize，再也不会增加，当任务数量陡增时，任务响应时间也将随之陡增。 maxPoolSize:当系统负载达到最大值时，核心线程数已无法按时处理完所有任务，这时就需要增加线程。 每秒 200 个任务需要 20 个线程，那么当每秒达到 1000 个任务时，则需要 ( 1000 - queueCapacity ) * ( 20 / 200 )，即 60 个线程，可将 maxPoolSize 设置为 60。 keepAliveTime:线程数量只增加不减少也不行。当负载降低时，可减少线程数量，如果一个线程空闲时间达到 keepAliveTiime，该线程就退出。 默认情况下线程池最少会保持 corePoolSize 个线程。 allowCoreThreadTimeout:默认情况下核心线程不会退出，可通过将该参数设置为 true，让核心线程也退出。 须知：以上关于线程数量的计算并没有考虑 CPU 的情况。 若结合 CPU 的情况，比如，当线程数量达到 50 时，CPU 达到 100%，则将 maxPoolSize 设置为 60 也不合适，此时若系统负载长时间维持在每秒 1000个 任务，则超出线程池处理能力，应设法降低每个任务的处理时间 ( tasktime )。 在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，（除非调用了 prestartAllCoreThreads () 或者 prestartCoreThread () 方法，从这 2 个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程）。 线程池监控在线程池中，线程池的监控也是很重要的一个点。 我们经常会注意的点有当前的排队线程池数，当前的活动线程数，执行完成线程数，总线程数。 123456789101112131415161718192021222324252627282930313233343536private static ExecutorService executor = new ThreadPoolExecutor(50, 100, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(100000));public static void main(String[] args) throws Exception &#123; for (int i = 0; i &lt; 100000; i++) &#123; executor.execute(() -&gt; &#123; System.out.print(1); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; ThreadPoolExecutor tpe = ((ThreadPoolExecutor) executor); while (true) &#123; System.out.println(); int queueSize = tpe.getQueue().size(); System.out.println("当前排队线程数：" + queueSize); int activeCount = tpe.getActiveCount(); System.out.println("当前活动线程数：" + activeCount); long completedTaskCount = tpe.getCompletedTaskCount(); System.out.println("执行完成线程数：" + completedTaskCount); long taskCount = tpe.getTaskCount(); System.out.println("总线程数：" + taskCount); Thread.sleep(3000); &#125;&#125; 深入源码分析Java线程池的实现原理Jdk提供给外部的接口也很简单。直接调用ThreadPoolExecutor构造一个就可以了，也可以通过Executors静态工厂构建，但一般不建议。 可以看到，开发者想要在代码中使用线程池还是比较简单的，这得益于Java给我们封装好的一系列API。但是，这些API的背后是什么呢，让我们来揭开这个迷雾，看清线程池的本质。 线程池构造函数 通常，一般构造函数会反映出这个工具或这个对象的数据存储结构。 [ 构造函数 如果把线程池比作一个公司。公司会有正式员工处理正常业务，如果工作量大的话，会雇佣外包人员来工作。 闲时就可以释放外包人员以减少公司管理开销。一个公司因为成本关系，雇佣的人员始终是有最大数。 如果这时候还有任务处理不过来，就走需求池排任务。 acc : 获取调用上下文 corePoolSize: 核心线程数量，可以类比正式员工数量，常驻线程数量。 maximumPoolSize: 最大的线程数量，公司最多雇佣员工数量。常驻+临时线程数量。 workQueue：多余任务等待队列，再多的人都处理不过来了，需要等着，在这个地方等。 keepAliveTime：非核心线程空闲时间，就是外包人员等了多久，如果还没有活干，解雇了。 threadFactory: 创建线程的工厂，在这个地方可以统一处理创建的线程的属性。每个公司对员工的要求不一样，恩，在这里设置员工的属性。 handler：线程池拒绝策略，什么意思呢?就是当任务实在是太多，人也不够，需求池也排满了，还有任务咋办?默认是不处理，抛出异常告诉任务提交者，我这忙不过来了。 添加一个任务 接着，我们看一下线程池中比较重要的execute方法，该方法用于向线程池中添加一个任务。 [ 源码 核心模块用红框标记了。 第一个红框：workerCountOf方法根据ctl的低29位，得到线程池的当前线程数，如果线程数小于corePoolSize，则执行addWorker方法创建新的线程执行任务; 第二个红框：判断线程池是否在运行，如果在，任务队列是否允许插入，插入成功再次验证线程池是否运行，如果不在运行，移除插入的任务，然后抛出拒绝策略。如果在运行，没有线程了，就启用一个线程。 第三个红框：如果添加非核心线程失败，就直接拒绝了。 这里逻辑稍微有点复杂，画了个流程图仅供参考 [ 接下来，我们看看如何添加一个工作线程的? 添加worker线程 从方法execute的实现可以看出：addWorker主要负责创建新的线程并执行任务，代码如下(这里代码有点长，没关系，也是分块的，总共有5个关键的代码块)： [ 第一个红框：做是否能够添加工作线程条件过滤： 判断线程池的状态，如果线程池的状态值大于或等SHUTDOWN，则不处理提交的任务，直接返回; 第二个红框：做自旋，更新创建线程数量： 通过参数core判断当前需要创建的线程是否为核心线程，如果core为true，且当前线程数小于corePoolSize，则跳出循环，开始创建新的线程 有人或许会疑问 retry 是什么?这个是java中的goto语法。只能运用在break和continue后面。 接着看后面的代码： [ 第一个红框：获取线程池主锁。 线程池的工作线程通过Woker类实现，通过ReentrantLock锁保证线程安全。 第二个红框：添加线程到workers中(线程池中)。 第三个红框：启动新建的线程。 接下来，我们看看workers是什么。 [ 一个hashSet。所以，线程池底层的存储结构其实就是一个HashSet。 worker线程处理队列任务 [ 第一个红框：是否是第一次执行任务，或者从队列中可以获取到任务。 第二个红框：获取到任务后，执行任务开始前操作钩子。 第三个红框：执行任务。 第四个红框：执行任务后钩子。 这两个钩子(beforeExecute，afterExecute)允许我们自己继承线程池，做任务执行前后处理。 到这里，源代码分析到此为止。接下来做一下简单的总结。 总结 所谓线程池本质是一个hashSet。多余的任务会放在阻塞队列中。 只有当阻塞队列满了后，才会触发非核心线程的创建。所以非核心线程只是临时过来打杂的。直到空闲了，然后自己关闭了。 线程池提供了两个钩子(beforeExecute，afterExecute)给我们，我们继承线程池，在执行任务前后做一些事情。 线程池原理关键技术：锁(lock,cas)、阻塞队列、hashSet(资源池) [ 线程池的底层数据结构采用HashSet来实现]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[about_http]]></title>
    <url>%2FNetWork%2F2019%2F04%2F23%2Fabout-http%2F</url>
    <content type="text"><![CDATA[什么是 HTTP 协议首先我们来看协议是什么？协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守有规则的文本格式。一但有了协议，就可以使很多公司分工起来，有些公司做 Server 端，如 Tomcat，而有些公司就可以做浏览器了。这样大家只要一套约定，彼此的通讯就会相互兼容。 接下来我们看什么是 HTTP？HTTP 是基于 TCP/IP 的应用层通信协议，它是客户端和服务器之间相互通信的标准。它规定了如何在互联网上请求和传输内容。通过应用层协议，我的意思是，它只是一个规范了主机（客户端和服务器）如何通信的抽象层，并且它本身依赖于 TCP/IP 来获取客户端和服务器之间的请求和响应。默认的 TCP 端口是80端口，当然，使用其他端口也是可以的。然而，HTTPS 使用的端口是443端口。 HTTP 协议的简单历史 第一阶段，1996年之前。第一版的 HTTP 文档是1991年提出来的 HTTP/0.9，其主要特点有：（1）它仅有一个 GET 方法。（2）没有 header 数据块。（3）必须以HTML格式响应。 第二阶段，HTTP/1.0 - 1996。HTML 格式响应，HTTP/1.0 能够处理其他的响应格式，例如：图像、视频文件、纯文本或其他任何的内容类型（Content-Type 来区分）。它增加了更多的方法（即 POST 和 HEAD），请求/响应的格式也发生了改变，请求和响应中均加入了 HTTP 头信息，响应数据还增加了状态码标识，还介绍了字符集的支持、多部分发送、权限、缓存、内容编码等很多内容。HTTP/1.0 的主要缺点之一是，你不能在每个连接中发送多个请求。也就是说，每当客户端要向服务器端请求东西时，它都会打开一个新的 TCP 连接，并且在这个单独请求完成后，该连接就会被关闭。每一次连接里面都包含了著名的三次握手协议。于是有些 HTTP/1.0 的实现试图通过引入一个新的头信息 Connection: keep-alive，来解决这个问题。 第三个阶段，HTTP/1.1 - 1999。HTTP/1.0 发布之后，随着 HTTP 开始普及之后，它的缺点也开始展现。时隔三年，HTTP/1.1 便在1999年问世，它在之前的基础上做了很多的改进。主要内容包含： 新增的 HTTP 方法有 PUT、PATCH、HEAD、OPTIONS、DELETE。 主机名标识。在 HTTP/1.0 中，Host 头信息不是必须项，但 HTTP/1.1 中要求必须要有 Host 头信息。 持久性连接。正如前面所说，在 HTTP/1.0 中每个连接只有一个请求，且在这个请求完成后该连接就会被关闭，从而会导致严重的性能下降及延迟问题。HTTP/1.1 引入了对持久性连接的支持，例如：默认情况下连接不会被关闭，在多个连续的请求下它会保存连接的打开状态。想要关闭这些连接，需要将 Connection: close 加入到请求的头信息中。客户端通常会在最后一次请求中发送这个头信息用来安全的关闭连接。 管道机制。HTTP/1.1 也引入了对管道机制的支持，客户端可以向服务器发送多个请求，而无需等待来自同一连接上的服务器响应，并且当收到请求时服务器必须以相同的顺序来响应。但你可能会问客户端是怎么知道第一个响应下载完成和下一个响应内容开始的？要解决这个问题，必须要有 Content-Length 头信息，客户端可以用它来确定响应结束，然后开始等待下一个响应。 第四个阶段，SPDY - 2009。Google 走在前面，它开始试验一种可替换的协议来减少网页的延迟，使得网页加载更快、提升 Web 安全性。2009年，他们称这种协议为 SPDY。SPDY 的功能包含多路复用、压缩、优先级、安全等。2015年，谷歌不想存在两个相互竞争的标准，因此他们决定把它合并到 HTTP 中成为 HTTP/2，同时放弃 SPDY。 第五个阶段，HTTP/2 - 2015。HTTP/2 是专为低延迟传输的内容而设计。关键特征或与 HTTP / 1.1 旧版本的差异，如下。 二进制协议。HTTP/2 倾向于使用二进制协议来减少 HTTP/1.x 中的延迟。二进制协议更容易解析，而不具有像 HTTP/1.x 中那样对人的可读性。HTTP/2 中的数据块是帧和流。帧和流： HTTP 消息是由一个或多个帧组成的。有一个叫做 HEADERS 的帧存放元数据，真正的数据是放在 DATA 帧中的，帧类型定义在the HTTP/2 specs（HTTP/2规范），如 HEADERS、DATA、RST_STREAM、SETTINGS、PRIORITY 等。每个 HTTP/2 请求和响应都被赋予一个唯一的流 ID 且放入了帧中。帧就是一块二进制数据。一系列帧的集合就称为流。每个帧都有一个流 id，用于标识它属于哪一个流，每一个帧都有相同的头。同时，除了流标识是唯一的，值得一提的是，客户端发起的任何请求都使用奇数和服务器的响应是偶数的流 id。除了 HEADERS 和 DATA， 另外一个值得说一说帧类型是 RST_STREAM，它是一个特殊的帧类型，用于中止流，如客户端发送这儿帧来告诉服务器我不再需要这个流了。在 HTTP/1.1 中只有一种方式来实现服务器停止发送响应给客户端，那就是关闭连接引起延迟增加，因为后续的请求就需要打开一个新的连接。 在 HTTP/2 中，客户端可以使用 RST_FRAME 来停止接收指定的流而不关闭连接且还可以在此连接中接收其它流。 多路复用。由于 HTTP/2 现在是一个二进制协议，且是使用帧和流来实现请求和响应，一旦 TCP 连接打开了，所有的流都通过这一连接来进行异步的发送而不需要打开额外的连接。反过来，服务器的响应也是异步的方式，如响应是无序的、客户端使用流 id 来标识属于流的包。这就解决了存在于 HTTP/1.x 中 head-of-line 阻塞问题，如客户端将不必耗时等待请求，而其他请求将被处理。如下图所示。 HPACK 头部压缩。它是一个单独的用于明确优化发送 Header RFC 的一部分。它的本质是，当我们同一个客户端不断的访问服务器时，在 header 中发送很多冗余的数据，有时 cookie 就增大 header，且消耗带宽和增加了延迟。为了解决这个问题， HTTP/2 引入了头部压缩。与请求和响应不同，header 不是使用 gzip 或 compress 等压缩格式，它有不同的机制，它使用了霍夫曼编码和在客户端和服务器维护的头部表来消除重复的 headers（如 User Agent)，在后续的请求中就只使用头部表中引用。它与 HTTP/1.1 中的一样，不过增加了伪 header，如 :method、:scheme、:host 和:path。 服务器推送。在服务器端，Server Push 是 HTTTP/2 的另外一个重要功能，我们知道，客户端是通过请求来获取资源的，它可以通过推送资源给客户端而不需客户端主动请求。例如，浏览器载入了一个页面，浏览器解析页面时发现了需要从服务器端载入的内容，接着它就发送一个请求来获取这些内容。Server Push允许服务器推送数据来减少客户端请求。它是如何实现的呢，服务器在一个新的流中发送一个特殊的帧 PUSH_PROMISE，来通知客户端：“嘿，我要把这个资源发给你!你就不要请求了。” 请求优先级。客户端可以在一个打开的流中在流的 HEADERS 帧中放入优先级信息。在任何时间，客户端都可以发送一个 PRIORITY 的帧来改变流的优先级。如果没有优先级信息，服务器就会异步的处理请求，比如无序处理。如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。 安全。大家对 HTTP/2 是否强制使用安全连接（通过 TLS）进行了充分的讨论。最后的决定是不强制使用。然而，大多数厂商表示，他们将只支持基于 TLS 的 HTTP/2。所以，尽管 HTTP/2 规范不需要加密，但它已经成为默认的强制执行的。在这种情况下，基于 TLS 实现的 HTTP/2 需要的 TLS 版本最低要求是1.2。 因此必须有最低限度的密钥长度、临时密钥等。 当然 HTTP 协议也在不断地进化过程中，在 HTTP1.1 基础上便有了 HTTP 2.0。 HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头，而且不考虑 pipeline 模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。 为了解决这些问题，HTTP 2.0 会对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key value 在两端建立一个索引表，对相同的头只发送索引表中的索引。 另外，HTTP 2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的 ID，而且流可以是客户端发往服务端，也可以是服务端发往客户端。它其实只是一个虚拟的通道。流是有优先级的。 HTTP 2.0 还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。常见的帧有Header 帧，用于传输 Header 内容，并且会开启一个新的流。再就是Data 帧，用来传输正文实体。多个 Data 帧属于同一个流。 通过这两种机制，HTTP 2.0 的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。这些帧可以打散乱序发送， 然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。 我们来举一个例子。 假设我们的一个页面要发送三个独立的请求，一个获取 css，一个获取 js，一个获取图片 jpg。如果使用 HTTP 1.1 就是串行的，但是如果使用 HTTP 2.0，就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。 HTTP 2.0 其实是将三个请求变成三个流，将数据分成帧，乱序发送到一个 TCP 连接中。 HTTP 2.0 成功解决了 HTTP 1.1 的队首阻塞问题，同时，也不需要通过 HTTP 1.x 的 pipeline 机制用多条 TCP 连接来实现并行请求与响应；减少了 TCP 连接数对服务器性能的影响，同时将页面的多个数据 css、js、 jpg 等通过一个数据链接进行传输，能够加快页面组件的传输速度。 HTTP 协议的具体内容而我们平时老生常谈的 HTTP 的协议大都是指的是 HTTP 1.1 协议的内容，接下去我们一起看一下 HTTP 1.1 协议的结构。如下图所示。 接下来，我将通过四部分大概介绍一下 HTTP 协议的基本内容。 1.URL &amp; URI 1schema://host[:port#]/path/.../[;url-params][?query-string][#anchor] URL（Uniform Resource Locator）主要包括以下几部分。 scheme：指定低层使用的协议，一般是 HTTP，如果强调安全的话可以是 HTTPS。 host：HTTP 服务器的 IP 地址或者域名。 port：HTTP 服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明。 path：访问资源的路径。 url-params：URL 的参数。 query-string：发送给 HTTP 服务器的数据。 anchor：锚。 URI，在 Java 的 Servlet 中指的是 resource path 部分。 2.请求方法 Method 主要包括以下几种请求方法。 GET：向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。 POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除 Request-URI 所标识的资源。 OPTIONS：这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用“*”来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。 HEAD：与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT：HTTP/1.1 协议中预留给能够将连接改为渠道方式的代理服务器。通常用于 SSL 加密服务器的链接（经由非加密的 HTTP 代理服务器）。 Method 名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码 405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码 501（Not Implemented）。 3.HTTP 之状态码 状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别: 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 常见状态码有： 1234567200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 4.请求体&amp;响应体 请求体&amp;响应体，这个没有特殊规定，需要配合不同的 Content-Type 来使用。 唯一需要注意的是 multipart/form-data、application/x-www-from-urlencoded、raw、binary 的区别。 （1）multipart/form-data 它将表单的数据组织成 Key-Value 形式，用分隔符 boundary（boundary 可任意设置）处理成一条消息。由于有 boundary 隔离，所以当即上传文件，又有参数的时候，必须要用这种 content-type 类型。如下图所示。 （2）x-www-form-urlencoded 即 application/x-www-from-urlencoded，将表单内的数据转换为 Key-Value。这种和 Get 方法把参数放在 URL 后面一样的想过，这种不能文件上传。 （3）raw 可以上传任意格式的“文本”，可以上传 Text、JSON、XML、HTML 等。 （4）binary 即 Content-Type:application/octet-stream，只可以上传二进制数据流，通常用来上传文件。由于没有键值，所以一次只能上传一个文件。 （5）Header HTTP 消息的 Headers 共分为三种，分别是 General Headers、Entity Headers、Request/Response Headers。 General Headers 我把被 Request 和 Response 共享的 Headers 成为General Headers，具体有： 123456789general-header = Cache-Control | Connection | Date | Pragma | Trailer | Transfer-Encoding | Upgrade | Via | Warning 其中，Cache-Control 指定请求和响应遵循的缓存机制；Connection 允许客户端和服务器指定与请求/响应连接有关的选项；Date 提供日期和时间标志，说明报文是什么时间创建的；Pragma 头域用来包含实现特定的指令，最常用的是 Pragma:no-cache；Trailer，如果报文采用了分块传输编码(chunked transfer encoding) 方式，就可以用这个首部列出位于报文拖挂（trailer）部分的首部集合；Transfer-Encoding 告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式；Upgrade 给出了发送端可能想要“升级”使用的新版本和协议；Via 显示了报文经过的中间节点（代理，网嘎un）。 Entity Headers Entity Headers 主要用来描述消息体（message body）的一些元信息，具体有： 12345678910entity-header = Allow | Content-Encoding | Content-Language | Content-Length | Content-Location | Content-MD5 | Content-Range | Content-Type | Expires | Last-Modified 其中，以 Content 为前缀的 Headers 主要描述了消息体的结构、大小、编码等信息，Expires 描述了 Entity 的过期时间，Last-Modified 描述了消息的最后修改时间。 Request/Response Headers Request-Line 是 Request 消息体的第一部分，其具体定义如下： 12345678Request-Line = Method SP URI SP HTTP-Version CRLFMethod = "OPTIONS" | "HEAD" | "GET" | "POST" | "PUT" | "DELETE" | "TRACE" 其中 SP 代表字段的分隔符，HTTP-Version 一般就是”http/1.1”，后面紧接着是一个换行。 在 Request-Line 后面紧跟着的就是 Headers。我们在上面已经介绍了 General Headers 和 Entity Headers，下面便是 Request Headers的定义。 12345678910111213141516171819request-header = Accept | Accept-Charset | Accept-Encoding | Accept-Language | Authorization | Expect | From | Host | If-Match | If-Modified-Since | If-None-Match | If-Range | If-Unmodified-Since | Max-Forwards | Proxy-Authorization | Range | Referer | TE | User-Agent Request Headers 扮演的角色其实就是一个 Request 消息的调节器。需要注意的是若一个 Headers 名称不在上面列表中，则默认当做 Entity Headers 的字段。前缀为 Accept 的 Headers 定义了客户端可以接受的媒介类型、语言和字符集等。From、Host、Referer 和 User-Agent 详细定义了客户端如何初始化 Request。前缀为 If 的 Headers 规定了服务器只能返回符合这些描述的资源，若不符合，则会返回 304 Not Modified。 Request Body，若 Request-Line 中的 Method 为 GET，请求中不包含消息体，若为 POST，则会包含消息体。 一个具体的 Request 消息实例，如下。 123456GET /articles/http-basics HTTP/1.1Host: www.articles.comConnection: keep-aliveCache-Control: no-cachePragma: no-cacheAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Response 消息体 Response 消息格式和 Request 类似，也分为三部分，即 Response-Line、Response Headers、Response Body。 Response-Line 具体定义如下： 1234Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLFHTTP-Version字段值一般为HTTP/1.1Status-Code前面已经讨论过了Reason-Phrase 是对status code的具体描述 一个最常见的 Response 响应为: 1HTTP/1.1 200 OK Response Headers的定义如下。 123456789response-header = Accept-Ranges | Age | ETag | Location | Proxy-Authenticate | Retry-After | Server | Vary | WWW-Authenticate 其中，Age 表示消息自 server 生成到现在的时长，单位是秒；ETag 是对 Entity 进行 MD5 hash 运算的值，用来检测更改；Location 是被重定向的 URL；Server 表示服务器标识。 缓存机制 HTTP 缓存1.如何缓存 降低网络上发送 HTTP 请求的次数，这里采用“过期”机制。 HTTP 服务器通过两种实体头（Entity-Header）来实现“过期”机制：Expires 头和 Cache-Control 头的 max-age 子项。 Expires/Cache-Control 控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只是 Cache-Control 比 Expires 可以控制的多一些，而且 Cache-Control 会重写 Expires 的规则。 降低网络上完整回复 HTTP 请求包的次数，这里采用“确证”机制。 HTTP服务器通过两种方式实现“确证”机制：ETag 以及 Last-Modified。 2.相关的 Header 主要包括以下几个。 Cache-Control 常用的值有： （1）max-age（单位为 s）指定设置缓存最大的有效时间，定义的是时间长短。当浏览器向服务器发送请求后，在 max-age 这段时间里浏览器就不会再向服务器发送请求了。 （2）s-maxage（单位为 s）同 max-age，只用于共享缓存（比如 CDN 缓存），也就是说 max-age 用于普通缓存，而 s-maxage 用于代理缓存。如果存在 s-maxage，则会覆盖掉 max-age 和 Expires header。 （3）public 指定响应会被缓存，并且在多用户间共享。如果没有指定 public 还是 private，则默认为 public。 （4）private 响应只作为私有的缓存，不能在用户间共享。如果要求 HTTP 认证，响应会自动设置为 private。 （5）no-cache 指定不缓存响应，表明资源不进行缓存，比如，设置了 no-cache 之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置 no-cache 防止缓存还是不够保险，还可以加上 private 指令，将过期时间设为过去的时间。 （6）no-store 表示绝对禁止缓存。一看就知道，如果用了这个命令，当然就是不会进行缓存啦！每次请求资源都要从服务器重新获取。 （7）must-revalidate 指定如果页面是过期的，则去服务器进行获取。这个指令并不常用，就不做过多的讨论了。 Expires 缓存过期时间，用来指定资源到期的时间，是服务器端的具体时间点。也就是说，Expires=max-age + 请求时间，需要和 Last-modified 结合使用。但在上面我们提到过 cache-control 的优先级更高。Expires 是 Web 服务器响应消息头字段，在响应 HTTP 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 Last-modified 服务器端文件的最后修改时间，需要和 cache-control 共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送 If-Modified-Since 报头，询问 Last-Modified 时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。 Etag 根据实体内容生成一段 hash 字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改。 为什么要使用 Etag 呢?Etag 主要为了解决 Last-Modified 无法解决的一些问题。 一些文件也许会周期性的更改，但是它的内容并不改变（仅仅改变的修改时间），这个时候我们并不希望客户端认为这个文件被修改了，而重新 Get。 某些文件修改非常频繁，比如在秒以下的时间内进行修改（比方说1s内修改了 N 次），If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断（或者说 UNIX 记录 MTIME 只能精确到秒）。 某些服务器不能精确的得到文件的最后修改时间。 缓存过程如下图所示。 Session 与 Cookie 必知必会很好的解决了 HTTP 通讯中状态问题，但其本身也存在一些问题，比如： 客户端存储，可能会被修改或删除。 发送请求时，Cookie 会被一起发送到服务器，当 Cookie 数据量较大时也会带来额外的请求数据量。 客户端对 Cookie 数量及大小有一定的限制，Session 解决了 Cookie 的一些缺点。Session 同样是为了记录用户状态，对于每个用户来说都会有相应的一个状态值保存在服务器中，而只在客户端记录一个 sessionID 用于区分是哪个用户的 Session。 与 Cookie 相比，Session有一定的优势，如： Session 值存储在服务器，相对来说更安全。 客户端发送给服务器的只有一个 sessionID，数据量更小。Session同样需要在客户端存储一个 sessionID。可以这个值存储在 Cookie，每次发送请求时通过 Cookie 请求头将其发送到服务器；也可以不使用 Cookie，而将 sessionID 作为一个额外的请求参数，通过 URL 或请求体发送到服务器。 基于 Cookie 实现 Session 的实现原理如下图的示。 由上可见，基于 Cookie 实现 Session 时，其本质上还是在客户端保存一个 Cookie 值。这个值就是 sessionID，sessionID 的名称也可按需要设置，为保存安全，其值也可能会在服务器端做加密处理。服务器在收到 sessionID 后，就可以对其解密及查找对应的用户信息等。 HTTP 与 HTTPS 的区别 HTTP（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。 HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。 HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。 HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式： 1、TCP 三次同步握手 2、客户端验证服务器数字证书 3、DH 算法协商对称加密算法的密钥、hash 算法的密钥 4、SSL 安全加密隧道协商完成 5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。 截至 2018 年 6 月，Alexa 排名前 100 万的网站中有 34.6% 使用 HTTPS 作为默认值，互联网 141387 个最受欢迎网站的 43.1% 具有安全实施的 HTTPS，以及 45% 的页面加载（透过Firefox纪录）使用HTTPS。2017 年3 月，中国注册域名总数的 0.11％使用 HTTPS。 根据 Mozilla 统计，自 2017 年 1 月以来，超过一半的网站流量被加密。 HTTP 与 HTTPS 区别 HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。 HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。 http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。 HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。 TCP 三次握手在TCP/IP协议中，TCP协议通过三次握手建立一个可靠的连接 第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认 第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态 第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手 简化： HTTPS 的工作原理我们都知道 HTTPS 能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用 HTTPS 协议。 1、客户端发起 HTTPS 请求 这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。 2、服务端的配置 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。 这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 3、传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 4、客户端解析证书 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。 如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 5、传送加密信息 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 6、服务段解密信息 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 7、传输加密后的信息 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 8、客户端解密信息 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。]]></content>
      <categories>
        <category>NetWork</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap-Infiniteloop]]></title>
    <url>%2FJava%2F2019%2F04%2F14%2FhashMap-infiniteLoop%2F</url>
    <content type="text"><![CDATA[Race Condition的由来(JDK7)问题的症状 我一直使用HashMap这个东西，但是当时Servlet编程，设计到的编程环境尽管有多线程但是不是对单个HashMap的并发操作，一切都没有问题，后来需求改了，很多地方需要考虑多线程了，于是变到多线程，有些情况自己去压测的时候，程序可以看到占了100%的CPU，查看堆栈，可以看到程序都会Hang在HashMap.get()这个方法上了，重启可以做到短暂性的问题消息。这个问题也是极少数出现。 我们查看自己的代码，HashMap被多个线程操作，而Java API说HashMap是非线程安全的，应该使用ConcurrentHashMap。 Hash表的数据结构 简单的说一下HashMap这个经典的数据结构。 HashMap通常会用一个指针数组（假设为table[]）来做分散所有的key，当一个key被加入的时候，通过Hash算法拿Key可以算出这个数组的下标i，然后把这个&lt;key,value&gt;插到table[i]中，如果有不同的key被算在了同一个i，那么就叫冲突，又叫做碰撞，这样会在table[i]上形成一个链表。 我们知道，如果table[]的尺寸非常小，比如只有两个，如果要放进去10个keys的话，那么碰撞会非常频繁，于是一个O(1)的查找算法，就变成了链表遍历，性能变成了O(n)，这是Hash表的缺陷。 这样一来，Hash表的尺寸和容量变得非常重要。一般来说，Hash表这个容器当有数据要插入的时候，都会检查容量有没有超过限定的thredhold，如果超过，需要增大Hash表的尺寸，但是这样一来，整个Hash表里的元素几乎都要重算一遍。这叫做rehash，成本相当的大。 正常ReHash的过程 假设我们的hash算法就是简单的用key mod一下表的大小（也就是数组的长度） 最上面的是 old hash表，其中Hash表的size=2，所以key=3,7,5，在mod 2以后都冲突到table[1]这里了 接下来的三个步骤是Hash表resize成4，然后所有的&lt;key,value&gt;重新rehash的过程 并发下ReHash的过程 JDK7下的HashMap的拉链中插入元素是头插法 1.于是我们假设有两个线程，线程一刚执行到定义下个Entry，就被挂起，紧接着线程二执行完成了 于是有了这个样子。 注意，因为Thread1的e指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。我们可以看到链表被反转后。 2.线程一被调度回来执行 先是执行newtable[i] = e; 然后是e=next，导致了e指向了key(7), 而下一次循环的next=e.next导致了next指向了key(3) 3.一切安好。 线程接着工作。把key(7)摘下来，放到newTable[i]的第一个，然后把e和next往下移 4.环形链接出现 e.next = newTable[i]导致key(3).next指向了key7 注意：此时的key(7).next 已经指向了key(3)，环形链表就这样出现了 于是当我们的线程一调用到，HashTable.get(11)时，悲剧就出现了——Infinitite Loop. 其它 JDK8已经修复了这个问题，在JDK8中，每个Entry采用尾插法 参考：&lt;https://coolshell.cn/articles/9606.html&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[time-management-dev-FirstDay]]></title>
    <url>%2FSlack%2F2019%2F04%2F13%2Fmiss-study-first%2F</url>
    <content type="text"><![CDATA[人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！ 无论到啥时候都要好好的安排好自己 记得时刻束缚自己]]></content>
      <categories>
        <category>Slack</category>
      </categories>
      <tags>
        <tag>Chat</tag>
        <tag>Awake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven-webxml attribute is required]]></title>
    <url>%2FJava%2F2019%2F04%2F12%2FMaven-webxml-attribute-is-required%2F</url>
    <content type="text"><![CDATA[Maven package a web application and hits the following error message : 1234567$ mvn package//...[ERROR] Failed to execute goal org.apache.maven.plugins:maven-war-plugin:2.2:war (default-war) on project spring4-mvc-maven-ajax-example: Error assembling WAR: webxml attribute is required (or pre-existing WEB-INF/web.xml if executing in update mode) -&gt; [Help 1] Solution1.For servlet container &lt; 3, make sure WEB-INF/web.xmlfile exists. 2.For servlet container &gt;=3, and NO WEB-INF/web.xml web application, declares the followingmaven-war-plugin plugin, and set the failOnMissingWebXml option to false. pom.xml 1234567891011121314 &lt;build&gt;&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;configuration&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ​]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>Web.xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS更新NodeJS]]></title>
    <url>%2FStudy%2F2019%2F04%2F11%2Fcentos-install-node%2F</url>
    <content type="text"><![CDATA[&lt;! – more – &gt; CentOS 下安装 Node.js​ 自己安装了好几次Node都没能够安装成功，今天自己再琢磨了一变，总算可拿出来了 我们知道CentOS通过yum安装也可以安装NodeJS，但是版本太老了，我自己通过执行 1sudo yum -y install nodejs 拿到了 6.14的版本，但是查看官网，最新版本是 ：Latest LTS Version: 10.15.3 (includes npm 6.4.1) 于是开始了折腾之旅 下载Nodejs 官网提供了编译好的 Linux 二进制包（不需要自己编译安装）官网 下载最新的Nodejs版本 ,本文以10.15.3 为例 cd /usr/local/ wget https://nodejs.org/dist/v10.15.3/node-v10.15.3-linux-x64.tar.xz 解压安装 tar -xvJf node-v10.15.3-linux-x64.tar.xz 配置NODE_HOME，进入profile编辑环境变量 vim /etc/profile 设置 nodejs 环境变量，在 export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL 一行的上面添加如下内容: #set for nodejsexport NODE_HOME=/usr/local/node-v10.15.3-linux-x64export PATH=$NODE_HOME/bin:$PATH :wq保存并退出，编译/etc/profile 使配置生效 source /etc/profile 验证是否安装配置成功 node -v 输出版本号标识配置成功 npm模块安装路径 /usr/local/node-v10.15.3-linux-x64/lib/node_modules/]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[懈怠]]></title>
    <url>%2FSlack%2F2019%2F04%2F11%2FAwakening.html%2F</url>
    <content type="text"><![CDATA[到底谁在看，到底是谁在懈怠 到底谁看立下看书和每天记录自己的flag人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！ 自己迷乱自己的一天，随时记录自己，文字最方便，在此立下flag 第一天上午：折腾Hexo 看书： ##]]></content>
      <categories>
        <category>Slack</category>
      </categories>
      <tags>
        <tag>Awake</tag>
        <tag>随笔</tag>
        <tag>Slack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread]]></title>
    <url>%2Funcategorized%2F2019%2F04%2F11%2FThread%2F</url>
    <content type="text"><![CDATA[## ## ##]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo_Next]]></title>
    <url>%2F%E5%BF%83%E5%BE%97%2F2019%2F04%2F09%2FHexo-Next%2F</url>
    <content type="text"><![CDATA[This is Test 更多剧情## ##]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello-World]]></title>
    <url>%2FSlack%2F2018%2F04%2F14%2FHello-World%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Slack</category>
      </categories>
      <tags>
        <tag>Awake</tag>
      </tags>
  </entry>
</search>
